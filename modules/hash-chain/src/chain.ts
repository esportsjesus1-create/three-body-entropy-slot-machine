/**
 * Hash Chain Generation and Verification
 * 
 * Implements hash chain functionality for provably fair gaming.
 * A hash chain is generated by repeatedly hashing a terminal seed,
 * then revealed in reverse order to prove fairness.
 */

import { createHash } from 'crypto';
import {
  HashChain,
  HashChainLink,
  GenerateChainOptions,
  VerificationResult,
  DeriveHashOptions,
  DeriveHashResult
} from './types';

/**
 * Computes a single hash using the specified algorithm.
 * 
 * @param data - Data to hash
 * @param algorithm - Hash algorithm (default: sha256)
 * @returns Hash as hex string
 */
export function computeHash(data: string, algorithm: string = 'sha256'): string {
  const hash = createHash(algorithm);
  hash.update(data);
  return hash.digest('hex');
}

/**
 * Generates a hash chain from a terminal seed.
 * The chain is generated by repeatedly hashing, starting from the terminal seed.
 * Hashes are stored in reveal order (index 0 = first to reveal = last generated).
 * 
 * @param options - Chain generation options
 * @returns Complete hash chain
 */
export function generateHashChain(options: GenerateChainOptions): HashChain {
  const { terminalSeed, length } = options;
  const algorithm = options.algorithm || 'sha256';

  if (!terminalSeed || terminalSeed.length === 0) {
    throw new Error('Terminal seed cannot be empty');
  }

  if (length <= 0) {
    throw new Error('Chain length must be positive');
  }

  if (length > 10000000) {
    throw new Error('Chain length exceeds maximum (10,000,000)');
  }

  // Generate chain by repeated hashing
  const hashes: string[] = [];
  let currentHash = terminalSeed;

  for (let i = 0; i < length; i++) {
    currentHash = computeHash(currentHash, algorithm);
    hashes.push(currentHash);
  }

  // Reverse so index 0 is the first to reveal (last generated)
  hashes.reverse();

  // Create chain links
  const links: HashChainLink[] = hashes.map((hash, index) => ({
    hash,
    index
  }));

  return {
    initialCommitment: hashes[0],
    hashes: links,
    length,
    algorithm
  };
}

/**
 * Verifies that a sequence of hashes forms a valid chain.
 * Each hash should be the hash of the next hash in the sequence.
 * 
 * @param initialCommitment - The first hash (commitment)
 * @param sequenceOfHashes - Array of hashes to verify
 * @param algorithm - Hash algorithm used (default: sha256)
 * @returns Verification result
 */
export function verifyHashChain(
  initialCommitment: string,
  sequenceOfHashes: string[],
  algorithm: string = 'sha256'
): VerificationResult {
  if (!initialCommitment || initialCommitment.length === 0) {
    return {
      valid: false,
      verifiedCount: 0,
      error: 'Initial commitment cannot be empty'
    };
  }

  if (sequenceOfHashes.length === 0) {
    return {
      valid: false,
      verifiedCount: 0,
      error: 'Sequence of hashes cannot be empty'
    };
  }

  // First hash should match the commitment
  if (sequenceOfHashes[0] !== initialCommitment) {
    return {
      valid: false,
      verifiedCount: 0,
      invalidIndex: 0,
      error: 'First hash does not match initial commitment'
    };
  }

  // Verify each subsequent hash
  for (let i = 1; i < sequenceOfHashes.length; i++) {
    const expectedHash = computeHash(sequenceOfHashes[i], algorithm);
    if (expectedHash !== sequenceOfHashes[i - 1]) {
      return {
        valid: false,
        verifiedCount: i,
        invalidIndex: i,
        error: `Hash at index ${i} does not chain to previous hash`
      };
    }
  }

  return {
    valid: true,
    verifiedCount: sequenceOfHashes.length
  };
}

/**
 * Verifies a single hash chain link against its predecessor.
 * 
 * @param currentHash - The current hash
 * @param nextHash - The next hash in the chain (should hash to current)
 * @param algorithm - Hash algorithm used
 * @returns True if the link is valid
 */
export function verifyChainLink(
  currentHash: string,
  nextHash: string,
  algorithm: string = 'sha256'
): boolean {
  const expectedHash = computeHash(nextHash, algorithm);
  return expectedHash === currentHash;
}

/**
 * Derives the next hash in a chain using previous hash, client seed, and nonce.
 * This is used for combining server and client entropy.
 * 
 * @param options - Derivation options
 * @returns Derived hash result
 */
export function deriveNextHash(options: DeriveHashOptions): DeriveHashResult {
  const { previousHash, clientSeed, nonce, additionalData } = options;

  if (!previousHash || previousHash.length === 0) {
    throw new Error('Previous hash cannot be empty');
  }

  if (!clientSeed || clientSeed.length === 0) {
    throw new Error('Client seed cannot be empty');
  }

  const nonceStr = String(nonce);
  
  // Combine all inputs
  let dataToHash = `${previousHash}:${clientSeed}:${nonceStr}`;
  if (additionalData) {
    dataToHash += `:${additionalData}`;
  }

  const hash = computeHash(dataToHash);

  return {
    hash,
    inputs: {
      previousHash,
      clientSeed,
      nonce: nonceStr,
      additionalData
    }
  };
}

/**
 * Gets a specific hash from a chain by index.
 * 
 * @param chain - The hash chain
 * @param index - Index of the hash to retrieve
 * @returns The hash at the specified index
 */
export function getHashAtIndex(chain: HashChain, index: number): string {
  if (index < 0 || index >= chain.length) {
    throw new Error(`Index ${index} out of bounds (0-${chain.length - 1})`);
  }
  return chain.hashes[index].hash;
}

/**
 * Gets a range of hashes from a chain.
 * 
 * @param chain - The hash chain
 * @param startIndex - Start index (inclusive)
 * @param endIndex - End index (exclusive)
 * @returns Array of hashes in the range
 */
export function getHashRange(
  chain: HashChain,
  startIndex: number,
  endIndex: number
): string[] {
  if (startIndex < 0 || startIndex >= chain.length) {
    throw new Error(`Start index ${startIndex} out of bounds`);
  }
  if (endIndex <= startIndex || endIndex > chain.length) {
    throw new Error(`End index ${endIndex} invalid`);
  }

  return chain.hashes.slice(startIndex, endIndex).map(link => link.hash);
}

/**
 * Calculates the remaining hashes in a chain from a given index.
 * 
 * @param chain - The hash chain
 * @param currentIndex - Current position in the chain
 * @returns Number of remaining hashes
 */
export function getRemainingHashes(chain: HashChain, currentIndex: number): number {
  if (currentIndex < 0 || currentIndex >= chain.length) {
    throw new Error(`Index ${currentIndex} out of bounds`);
  }
  return chain.length - currentIndex - 1;
}

/**
 * Creates a partial chain for verification purposes.
 * Only includes hashes from startIndex to endIndex.
 * 
 * @param chain - The full hash chain
 * @param startIndex - Start index
 * @param endIndex - End index
 * @returns Partial hash chain
 */
export function createPartialChain(
  chain: HashChain,
  startIndex: number,
  endIndex: number
): HashChain {
  const hashes = chain.hashes.slice(startIndex, endIndex);
  
  return {
    initialCommitment: hashes[0]?.hash || '',
    hashes: hashes.map((link, i) => ({
      hash: link.hash,
      index: i,
      metadata: link.metadata
    })),
    length: hashes.length,
    algorithm: chain.algorithm
  };
}

/**
 * Extends an existing hash chain by generating more hashes.
 * Note: This requires the terminal seed, which should be kept secret.
 * 
 * @param terminalSeed - The original terminal seed
 * @param existingLength - Current chain length
 * @param additionalLength - Number of hashes to add
 * @param algorithm - Hash algorithm
 * @returns Extended hash chain
 */
export function extendHashChain(
  terminalSeed: string,
  existingLength: number,
  additionalLength: number,
  algorithm: string = 'sha256'
): HashChain {
  return generateHashChain({
    terminalSeed,
    length: existingLength + additionalLength,
    algorithm
  });
}

/**
 * Converts a hash to a numeric value for use in game logic.
 * 
 * @param hash - Hash to convert
 * @param maxValue - Maximum value (exclusive)
 * @returns Numeric value in range [0, maxValue)
 */
export function hashToNumber(hash: string, maxValue: number): number {
  if (maxValue <= 0) {
    throw new Error('Max value must be positive');
  }

  // Use first 8 characters (32 bits) of hash
  const hexSubstring = hash.substring(0, 8);
  const numericValue = parseInt(hexSubstring, 16);
  
  return numericValue % maxValue;
}

/**
 * Converts a hash to a floating point value in range [0, 1).
 * 
 * @param hash - Hash to convert
 * @returns Float value in range [0, 1)
 */
export function hashToFloat(hash: string): number {
  // Use first 13 characters (52 bits) for double precision
  const hexSubstring = hash.substring(0, 13);
  const numericValue = parseInt(hexSubstring, 16);
  const maxValue = Math.pow(16, 13);
  
  return numericValue / maxValue;
}
